"""
КОНСПЕКТ ПО СЛОВАРЯМ (DICTIONARIES) В PYTHON
Источник: https://www.w3schools.com/python/python_dictionaries.asp
"""

# =============================================
# 1. Создание и базовые операции
# =============================================

# 1.1 Создание словарей
dict1 = {}                              # Пустой словарь
dict2 = {"name": "Alice", "age": 30}    # Ключи и значения
dict3 = dict(name="Bob", age=25)        # Конструктор dict()
dict4 = {1: "one", (2,3): "tuple_key"}  # Разные типы ключей

# Некорректные ключи (изменяемые типы):
# invalid_dict = {[1,2]: "value"}       # TypeError: unhashable type

print(dict2["name"])  # Alice (доступ по ключу)

# 1.2 Добавление/изменение элементов
dict2["email"] = "alice@mail.com"    # Добавление
dict2["age"] = 31                    # Изменение
dict2.update({"city": "Paris", "age": 32})  # Множественное обновление

# =============================================
# 2. Основные методы словарей
# =============================================

# 2.1 Получение значений
print(dict2.get("phone", "N/A"))     # N/A (нет ключа, но нет ошибки)
print(dict2.setdefault("phone", "+1234567890"))  # Устанавливает значение по умолчанию

# 2.2 Удаление элементов
popped_value = dict2.pop("age")      # Удаляет ключ и возвращает значение
del dict2["city"]                    # Удаление без возврата значения
dict2.clear()                        # Полная очистка

# 2.3 Получение ключей и значений
keys = dict4.keys()      # dict_keys([1, (2, 3)])
values = dict4.values()  # dict_values(['one', 'tuple_key'])
items = dict4.items()    # dict_items([(1, 'one'), ((2, 3), 'tuple_key')])

# =============================================
# 3. Особенности работы с ключами
# =============================================

# 3.1 Требования к ключам:
# - Неизменяемые типы (str, int, float, tuple)
# - Уникальность (дубликаты ключей перезаписываются)

# 3.2 Проверка наличия ключа
print("name" in dict2)  # True

# 3.3 Слияние словарей (Python 3.9+)
dict_a = {"a": 1, "b": 2}
dict_b = {"b": 3, "c": 4}
merged = dict_a | dict_b  # {'a': 1, 'b': 3, 'c': 4}

# =============================================
# 4. Итерация по словарю
# =============================================

user = {"name": "John", "age": 30, "city": "London"}

# 4.1 Перебор ключей
for key in user:
    print(key)          # name, age, city

# 4.2 Перебор пар ключ-значение
for key, value in user.items():
    print(f"{key}: {value}")

# 4.3 Генераторы словарей
squared = {x: x**2 for x in range(5)}  # {0:0, 1:1, 2:4, 3:9, 4:16}

# =============================================
# 5. Вложенные словари
# =============================================

employees = {
    "manager": {
        "name": "Alice",
        "age": 35
    },
    "developer": {
        "name": "Bob",
        "skills": ["Python", "JS"]
    }
}

print(employees["developer"]["skills"][0])  # Python

# =============================================
# 6. Практические примеры
# =============================================

# 6.1 Подсчет частоты элементов
text = "abracadabra"
frequency = {}
for char in text:
    frequency[char] = frequency.get(char, 0) + 1
# {'a': 5, 'b': 2, 'r': 2, 'c': 1, 'd': 1}

# 6.2 Преобразование списка в словарь
names = ["Alice", "Bob", "Charlie"]
name_dict = {index: name for index, name in enumerate(names, 1)}
# {1: 'Alice', 2: 'Bob', 3: 'Charlie'}

# 6.3 Конфигурация настроек
config = {
    "debug_mode": True,
    "max_connections": 10,
    "allowed_ports": [80, 443, 8080]
}

"""
КЛЮЧЕВЫЕ ТЕЗИСЫ:
1. Словари хранят пары ключ-значение (неупорядоченные в Python <3.7)
2. Ключи должны быть неизменяемыми и уникальными
3. Основные методы: get(), pop(), update(), items(), keys(), values()
4. Используйте in для проверки наличия ключа
5. Для безопасного доступа к значениям используйте get() вместо []
6. Словарные включения {key: value for ...} аналогичны списковым
7. Поддерживают сложные структуры данных через вложенность
8. Эффективны для поиска по ключу (O(1) в среднем случае)
9. Версии Python 3.7+ сохраняют порядок добавления элементов
10. | оператор (Python 3.9+) объединяет словари с приоритетом правого
11. Используйте словари для:
    - Конфигураций и настроек
    - Подсчета частоты элементов
    - Быстрого поиска данных
    - Представления JSON-подобных структур
"""